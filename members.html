<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Members ‚Äî AI Indicator Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <style>
    body{margin:0;font-family:"Segoe UI",Roboto,Helvetica,Arial,sans-serif;background:#0f172a;color:#f9fafb;line-height:1.6}
    .wrap{max-width:980px;margin:0 auto;padding:40px 20px}
    h1{font-size:1.9rem;margin:0 0 8px;color:#38bdf8}
    .meta{color:#93a4c1;font-size:.95rem;margin-bottom:16px}
    .toc{position:sticky;top:0;background:#0f172a;padding:10px 0;margin:-10px 0 10px 0;z-index:1;text-align:center}
    .pill{display:inline-block;margin:6px 8px;padding:6px 12px;border-radius:999px;background:#0b1220;border:1px solid #334155;color:#cbd5e1;font-size:.9rem;text-decoration:none}
    .pill:hover{background:#1e293b;color:#38bdf8}
    .box{margin:22px 0;padding:18px;background:#1e293b;border-radius:12px}
    .box h2{color:#38bdf8;margin:0 0 12px;font-size:1.2rem}
    details{background:#0f172a;border:1px solid #334155;border-radius:10px;margin:14px 0;padding:12px}
    details>summary{cursor:pointer;font-weight:700;outline:none}
    .tag{display:inline-block;font-size:.85rem;background:#0b1220;border:1px solid #334155;border-radius:999px;padding:3px 8px;margin-left:8px;color:#cbd5e1}
    .code{background:#0b1220;color:#93c5fd;padding:12px;border-radius:8px;overflow:auto;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:.95rem}
    .sep{height:1px;background:#334155;margin:20px 0}
    .btn{display:inline-block;margin-top:12px;padding:12px 20px;border-radius:10px;font-weight:700;text-decoration:none;background:#38bdf8;color:#0f172a}
    .btn:hover{background:#0ea5e9}
    footer{margin-top:28px;padding:14px 0;color:#94a3b8;border-top:1px solid #1e293b;font-size:.9rem}
    a{color:#38bdf8;text-decoration:none}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Members Area</h1>
    <div class="meta">
      Private access for subscribers. Please do not share this URL.  
      For Grade 3 EA requests: <a href="mailto:tayama10@icloud.com">tayama10@icloud.com</a>
    </div>

    <!-- Quick Jump -->
    <nav class="toc">
      <a class="pill" href="#latest">‚¨áÔ∏è Jump to Latest Week</a>
      <a class="pill" href="#m1w1">Month 1 ‚Äî Week 1</a>
      <a class="pill" href="#m1w2">Month 1 ‚Äî Week 2</a>
      <a class="pill" href="#m1w3">Month 1 ‚Äî Week 3</a>
    </nav>

    <div class="box">
      <h2>üìä Weekly Indicators</h2>

      <!-- Month 1 ‚Äî Week 1 -->
      <section id="m1w1">
        <h3>Month 1 ‚Äî Week 1: Entropy Volatility Oscillator (EVO) <span class="tag">Trend Filter</span></h3>
        <details open>
          <summary>Concept / Logic / Use case</summary>
          <p><strong>Concept:</strong> EVO measures unpredictability using rolling Shannon entropy of log returns. Low entropy implies structured movement (trend-prone), high entropy implies choppy/noisy markets.</p>
          <p><strong>Logic:</strong> Compute log returns ‚Üí bucketize into discrete bins ‚Üí estimate Shannon entropy over a rolling window ‚Üí normalize to 0‚Äì100 oscillator. Thresholds: &lt;30 trend-friendly, &gt;70 chop.</p>
          <p><strong>Use case:</strong> Use as a filter for entries: trade trend setups only when EVO &lt; 30; stand aside or reduce size when EVO &gt; 70. Combine with MA cross or Donchian breakout.</p>
        </details>
        <pre class="code">
//+------------------------------------------------------------------+
//| Entropy Volatility Oscillator (EVO) ‚Äî AI Indicator Lab          |
//+------------------------------------------------------------------+
#property indicator_separate_window
#property indicator_buffers 1
#property indicator_plots   1
#property indicator_label1  "EVO"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrDeepSkyBlue
#property indicator_style1  STYLE_SOLID
#property indicator_width1  2

input int      EvoWindow   = 50;   // Entropy window
input int      Bins        = 7;    // Histogram bins (3..12)
input double   MinRet      = -0.01;// Lower bound for binning (~1%)
input double   MaxRet      =  0.01;// Upper bound for binning (~1%)

double EvoBuffer[];

int OnInit(){
   SetIndexBuffer(0,EvoBuffer,INDICATOR_DATA);
   IndicatorSetInteger(INDICATOR_MINIMUM,0);
   IndicatorSetInteger(INDICATOR_MAXIMUM,100);
   return(INIT_SUCCEEDED);
}

// map return to bin index
int RetToBin(double r){
   if(r<=MinRet) return 0;
   if(r>=MaxRet) return Bins-1;
   double step=(MaxRet-MinRet)/(Bins-1);
   return (int)MathFloor((r-MinRet)/step+0.5);
}

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const int begin,
                const double &price[]){
   if(rates_total<EvoWindow+2) return(0);

   int start = MathMax(prev_calculated-1,EvoWindow+2);
   if(start<0) start=EvoWindow+2;

   static double close[];
   ArraySetAsSeries(close,true);
   CopyClose(Symbol(),Period(),0,rates_total,close);

   for(int i=start; i<rates_total; i++){
      // build histogram counts within window
      int counts[21]; ArrayInitialize(counts,0); // up to 21 bins
      int bins=MathMax(3,MathMin(12,Bins));
      int win = EvoWindow;

      // compute log returns and fill bins
      for(int k=0; k<win && (i-k-1)>=0; k++){
         double r = MathLog(close[i-k]/close[i-k-1]);
         int b = MathMax(0,MathMin(bins-1, RetToBin(r)));
         counts[b]++;
      }
      // Shannon entropy
      double H=0.0;
      for(int b=0;b<bins;b++){
         if(counts[b]<=0) continue;
         double p = (double)counts[b]/(double)win;
         H -= p*MathLog(p); // natural log
      }
      // normalize: max entropy ~ ln(bins)
      double Hmax = MathLog((double)bins);
      double evo = (H/Hmax)*100.0;
      EvoBuffer[i]=evo;
   }
   return(rates_total);
}
        </pre>
      </section>

      <div class="sep"></div>

      <!-- Month 1 ‚Äî Week 2 -->
      <section id="m1w2">
        <h3>Month 1 ‚Äî Week 2: Liquidity Gap Detector (LGD) <span class="tag">Mean Reversion</span></h3>
        <details>
          <summary>Concept / Logic / Use case</summary>
          <p><strong>Concept:</strong> Detects "liquidity voids" where consecutive candles barely overlap (gap-like structure on intrabar liquidity), often revisited later.</p>
          <p><strong>Logic:</strong> For each bar pair, compute overlap ratio between [Low, High] intervals. If overlap &lt; threshold (e.g., 10%), mark the void as a rectangle region on chart.</p>
          <p><strong>Use case:</strong> Mean-reversion targets: anticipate partial or full fills into prior voids. Combine with ATR-based stops beyond the gap zone.</p>
        </details>
        <pre class="code">
//+------------------------------------------------------------------+
//| Liquidity Gap Detector (LGD) ‚Äî AI Indicator Lab                  |
//+------------------------------------------------------------------+
#property indicator_chart_window
input double OverlapThreshold = 0.10; // 10% overlap considered a void
input int    LookbackBars     = 500;  // bars to scan
input color  GapColor         = clrRoyalBlue;
input int    Opacity          = 20;   // rectangle opacity (0..255)

string RectName(int i){ return "LGD_"+IntegerToString(i); }

int OnInit(){ return(INIT_SUCCEEDED); }

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const int begin,
                const double &price[]){
   if(rates_total<3) return(0);

   int start = (prev_calculated>0 ? prev_calculated-1 : 1);
   int from  = MathMax(1, rates_total - MathMax(LookbackBars,100));

   // clean old rectangles beyond lookback
   for(int j=0;j<from-2;j++){
      string name=RectName(j);
      if(ObjectFind(0,name)>=0) ObjectDelete(0,name);
   }

   MqlRates rates[];
   ArraySetAsSeries(rates,true);
   CopyRates(Symbol(),Period(),0,rates_total,rates);

   for(int i=MathMax(start,from); i<rates_total; i++){
      double h1=rates[i].high, l1=rates[i].low;
      double h2=rates[i-1].high, l2=rates[i-1].low;

      double top = MathMin(h1,h2);
      double bot = MathMax(l1,l2);
      double overlap = MathMax(0.0, top-bot);
      double unionLen = MathMax(h1,h2) - MathMin(l1,l2);
      if(unionLen<=0) continue;
      double ratio = overlap/unionLen;

      if(ratio < OverlapThreshold){
         // define gap zone between the two bar midpoints
         datetime t1 = rates[i-1].time;
         datetime t2 = rates[i].time + (rates[i].time - rates[i-1].time)/2;
         string name = RectName(i);
         if(ObjectFind(0,name)>=0) ObjectDelete(0,name);
         ObjectCreate(0,name,OBJ_RECTANGLE,0,t1,bot,t2,top);
         ObjectSetInteger(0,name,OBJPROP_COLOR,GapColor);
         ObjectSetInteger(0,name,OBJPROP_BACK,true);
         ObjectSetInteger(0,name,OBJPROP_STYLE,STYLE_SOLID);
         ObjectSetInteger(0,name,OBJPROP_WIDTH,1);
         ObjectSetInteger(0,name,OBJPROP_FILL,true);
         ObjectSetInteger(0,name,OBJPROP_ZORDER,0);
         ObjectSetInteger(0,name,OBJPROP_ALPHA,Opacity);
      }
   }
   return(rates_total);
}
        </pre>
      </section>

      <div class="sep"></div>

      <!-- Month 1 ‚Äî Week 3 (Latest) -->
      <section id="latest">
        <h3>Month 1 ‚Äî Week 3: Adaptive Fractal Momentum (AFM) <span class="tag">Momentum</span></h3>
        <details>
          <summary>Concept / Logic / Use case</summary>
          <p><strong>Concept:</strong> Momentum that self-tunes with market structure. When price exhibits trend-like fractal properties (lower fractal dimension), AFM becomes more responsive; in noisy ranges (higher dimension), AFM slows down.</p>
          <p><strong>Logic:</strong> Estimate a simple fractal dimension proxy from rolling range vs. ATR; map it to a dynamic smoothing factor; compute a normalized momentum line (0‚Äì100).</p>
          <p><strong>Use case:</strong> Works as a noise-aware momentum. Use cross-ups over 60 in trends, avoid signals when AFM stays below 40 during ranges.</p>
        </details>
        <pre class="code">
//+------------------------------------------------------------------+
//| Adaptive Fractal Momentum (AFM) ‚Äî AI Indicator Lab               |
//+------------------------------------------------------------------+
#property indicator_separate_window
#property indicator_buffers 1
#property indicator_plots   1
#property indicator_label1  "AFM"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrDeepSkyBlue
#property indicator_width1  2

input int    BasePeriod   = 14;   // base lookback
input int    SmoothMin    = 3;    // fastest smoothing when trending
input int    SmoothMax    = 30;   // slowest smoothing when ranging
input int    MapWindow    = 50;   // window for fractal proxy

double Afm[];

int OnInit(){
   SetIndexBuffer(0,Afm,INDICATOR_DATA);
   IndicatorSetInteger(INDICATOR_MINIMUM,0);
   IndicatorSetInteger(INDICATOR_MAXIMUM,100);
   return(INIT_SUCCEEDED);
}

// simple proxy: fractal-ness via Range / (ATR * sqrt(n))
double FractalProxy(int i, int n){
   if(i-n<1) return 1.0;
   double hi = iHigh(Symbol(),Period(),iHighest(Symbol(),Period(),MODE_HIGH,n,i-n+1));
   double lo = iLow(Symbol(),Period(),iLowest(Symbol(),Period(),MODE_LOW,n,i-n+1));
   double range = hi - lo;
   double atr = iATR(Symbol(),Period(),n,i);
   if(atr<=0) atr=0.0000001;
   double proxy = range / (atr * MathSqrt(n));
   // proxy small => noisy; large => directional. Map to [0,1]
   double p = MathMin(3.0,MathMax(0.2,proxy));
   return (p-0.2)/(3.0-0.2);
}

double EmaStep(double prev,double cur,double alpha){ return prev + alpha*(cur-prev); }

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const int begin,
                const double &price[]){
   if(rates_total<MathMax(MapWindow,BasePeriod)+2) return(0);

   static double close[];
   ArraySetAsSeries(close,true);
   CopyClose(Symbol(),Period(),0,rates_total,close);

   int start=MathMax(prev_calculated-1, BasePeriod+2);
   if(start<0) start=BasePeriod+2;

   double prev=50.0;
   for(int i=start;i<rates_total;i++){
      // raw momentum: rate of change over BasePeriod
      double roc = (close[i]-close[i-BasePeriod]);
      double norm = 50.0 + 50.0 * MathTanh( (roc)/(Point()*BasePeriod*10.0) );

      // get fractal proxy [0..1] then map to smoothing period
      double fp = FractalProxy(i, MapWindow);
      int smooth = (int)MathRound( SmoothMax - fp*(SmoothMax-SmoothMin) );
      double alpha = 2.0/(smooth+1.0);

      prev = EmaStep(prev, norm, alpha);
      Afm[i]=MathMax(0.0,MathMin(100.0,prev));
   }
   return(rates_total);
}
        </pre>
      </section>

    </div>

    <a class="btn" href="./index.html">Back to Overview</a>
    <footer>¬© 2025 AI Indicator Lab ‚Äî Private content for subscribers (noindex)</footer>
  </div>
</body>
</html>
